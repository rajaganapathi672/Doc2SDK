import datetime
import jinja2
from typing import Dict, Any, List
from ..parsers.openapi import NormalizedAPISpec

PYTHON_SDK_TEMPLATE = """
# Generated by Doc2SDK
# API: {{ name }} v{{ version }}
# Generated: {{ generated_at }}

from typing import Optional, Dict, Any, List
from dataclasses import dataclass
from enum import Enum
import httpx
import logging
from tenacity import retry, stop_after_attempt, wait_exponential

logger = logging.getLogger(__name__)

class {{ name.replace(' ', '') }}APIError(Exception):
    \"\"\"Base exception for {{ name }} API errors\"\"\"
    def __init__(self, message: str, status_code: int, response: Dict):
        self.message = message
        self.status_code = status_code
        self.response = response
        super().__init__(self.message)

class {{ name.replace(' ', '') }}Client:
    \"\"\"
    {{ name }} API Client
    \"\"\"
    
    def __init__(
        self,
        api_key: str = None,
        base_url: str = "{{ base_url }}",
        timeout: int = 30,
        max_retries: int = 3
    ):
        self.api_key = api_key
        self.base_url = base_url
        self.timeout = timeout
        self.max_retries = max_retries
        
        headers = {
            "Content-Type": "application/json",
            "User-Agent": "Doc2SDK-SDK/1.0"
        }
        if api_key:
            {% if authentication.type == 'bearer' %}
            headers["Authorization"] = f"Bearer {api_key}"
            {% elif authentication.type == 'apiKey' %}
            headers["{{ authentication.name }}"] = api_key
            {% endif %}

        self.client = httpx.Client(
            base_url=base_url,
            timeout=timeout,
            headers=headers
        )

    {% for endpoint in endpoints %}
    def {{ endpoint.summary.lower().replace(' ', '_') if endpoint.summary else endpoint.method.lower() + endpoint.path.replace('/', '_').replace('{', '').replace('}', '') }}(
        self,
        {% if endpoint.parameters and endpoint.parameters.path %}
        {% for p in endpoint.parameters.path %}
        {{ p.name }}: {{ p.type }},
        {% endfor %}
        {% endif %}
        **kwargs
    ) -> Dict[str, Any]:
        \"\"\"
        {{ endpoint.summary or endpoint.path }}
        {{ endpoint.description }}
        \"\"\"
        path = f"{{ endpoint.path }}"
        {% if endpoint.parameters and endpoint.parameters.path %}
        {% for p in endpoint.parameters.path %}
        path = path.replace("{{ '{' + p.name + '}' }}", str({{ p.name }}))
        {% endfor %}
        {% endif %}
        
        try:
            response = self.client.request(
                "{{ endpoint.method }}",
                path,
                params=kwargs.get("params"),
                json=kwargs.get("json"),
                headers=kwargs.get("headers")
            )
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            raise {{ name.replace(' ', '') }}APIError(
                message=str(e),
                status_code=e.response.status_code,
                response=e.response.json() if e.response.content else {}
            )
    {% endfor %}

    def close(self):
        self.client.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
"""

TYPESCRIPT_SDK_TEMPLATE = """
/**
 * Generated by Doc2SDK
 * API: {{ name }} v{{ version }}
 * Generated: {{ generated_at }}
 */

import axios, { AxiosInstance, AxiosError } from 'axios';

export class {{ name.replace(' ', '') }}APIError extends Error {
    constructor(
        public message: string,
        public statusCode?: number,
        public response?: any
    ) {
        super(message);
        this.name = '{{ name.replace(' ', '') }}APIError';
    }
}

export interface {{ name.replace(' ', '') }}Config {
    apiKey?: string;
    baseUrl?: string;
    timeout?: number;
}

export class {{ name.replace(' ', '') }}Client {
    private client: AxiosInstance;

    constructor(config: {{ name.replace(' ', '') }}Config = {}) {
        const {
            apiKey,
            baseUrl = "{{ base_url }}",
            timeout = 30000
        } = config;

        const headers: Record<string, string> = {
            'Content-Type': 'application/json',
            'User-Agent': 'Doc2SDK-SDK/1.0'
        };

        if (apiKey) {
            {% if authentication.type == 'bearer' %}
            headers['Authorization'] = `Bearer ${apiKey}`;
            {% elif authentication.type == 'apiKey' %}
            headers['{{ authentication.name }}'] = apiKey;
            {% endif %}
        }

        this.client = axios.create({
            baseURL: baseUrl,
            timeout,
            headers
        });
    }

    {% for endpoint in endpoints %}
    /**
     * {{ endpoint.summary or endpoint.path }}
     * {{ endpoint.description }}
     */
    async {{ (endpoint.summary.charAt(0).toLowerCase() + endpoint.summary.slice(1)).replace(' ', '') if endpoint.summary else endpoint.method.toLowerCase() + endpoint.path.replace('/', '_').replace('{', '').replace('}', '') }}(
        {% if endpoint.parameters and endpoint.parameters.path %}
        {% for p in endpoint.parameters.path %}
        {{ p.name }}: any,
        {% endfor %}
        {% endif %}
        data?: any,
        params?: any
    ): Promise<any> {
        let path = `{{ endpoint.path }}`;
        {% if endpoint.parameters and endpoint.parameters.path %}
        {% for p in endpoint.parameters.path %}
        path = path.replace("{{ '{' + p.name + '}' }}", String({{ p.name }}));
        {% endfor %}
        {% endif %}

        try {
            const response = await this.client.request({
                method: '{{ endpoint.method }}',
                url: path,
                data,
                params
            });
            return response.data;
        } catch (error) {
            const axiosError = error as AxiosError;
            throw new {{ name.replace(' ', '') }}APIError(
                axiosError.message,
                axiosError.response?.status,
                axiosError.response?.data
            );
        }
    }
    {% endfor %}
}
"""

class CodeGenerator:
    def __init__(self):
        self.env = jinja2.Environment()

    def generate_sdk(self, spec: NormalizedAPISpec, language: str = "python") -> str:
        if language.lower() == "python":
            template = self.env.from_string(PYTHON_SDK_TEMPLATE)
        elif language.lower() == "typescript" or language.lower() == "ts":
            template = self.env.from_string(TYPESCRIPT_SDK_TEMPLATE)
        else:
            raise ValueError(f"Language {language} not supported")

        return template.render(
            name=spec.name,
            version=spec.version,
            base_url=spec.base_url,
            authentication=spec.authentication,
            endpoints=spec.endpoints,
            generated_at=datetime.datetime.utcnow().isoformat()
        )

    def generate_python_sdk(self, spec: NormalizedAPISpec) -> str:
        return self.generate_sdk(spec, "python")
